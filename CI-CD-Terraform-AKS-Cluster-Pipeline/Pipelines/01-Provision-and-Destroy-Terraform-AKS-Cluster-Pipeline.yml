
trigger:
 paths:
   include:
     - Pipelines/01-Provision-and-Destroy-Terraform-AKS-Cluster-Pipeline.yml
    

  

pool: Default
  
#Stage-1: Terraform Validate Stage
   ##Step-1: Publish Artifacts to Pipeline 
   ##Step-2: Install Terraform 
   ##Step-3: Validate Terraform Manifest

stages:
  - stage: TerraformValidate
    jobs:
      - job: TerraformValidateJob
        continueOnError: false
        steps:
        - task: TerraformInstaller@1
          displayName: Terraform Install
          inputs:
            terraformVersion: 'latest'
        - task: TerraformTask@5
          displayName: Terraform Init
          inputs:
            provider: 'azurerm'
            command: 'init'
            workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
            backendAzureRmUseEntraIdForAuthentication: false
            backendServiceArm: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
            backendAzureRmResourceGroupName: 'terraform-storage-rg'
            backendAzureRmStorageAccountName: 'terraformstorage05'
            backendAzureRmContainerName: 'tfstatebackupfile'
            backendAzureRmKey: 'prodcluster.tfstate'
        - task: TerraformTask@5
          displayName: Terraform Validate
          inputs:
            provider: 'azurerm'
            command: 'validate'
            workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'

# Stage-2: Deploy Stages for Prod Cluster

    ## Step-1: Terraform Install
    ## Step-2: Download SSH Secure File
    ## Step-3: Terraform Initialize 
    ## Step-4: Terraform Plan 
    ## Step-5: Terraform Apply 
    ## Step-6: When you want De-Comission AKS Cluster then Uncomment "destroy task" and the re-run pipeline.

  - stage: DeployProdCluster
    jobs:
      - job: DeployProdCluster
        displayName: DeployProdCluster
        pool: Default
        steps: 
              - task: TerraformInstaller@1
                displayName: Terraform Install
                inputs:
                  terraformVersion: 'latest'
              - task: DownloadSecureFile@1
                displayName: Download SSH Key
                name: sshkey
                inputs:
                  secureFile: 'aks-terraform-devops-ssh-key-ubuntu.pub'
              - task: TerraformTask@5
                displayName: Terraform Init
                inputs:
                  provider: 'azurerm'
                  command: 'init'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
                  backendAzureRmUseEntraIdForAuthentication: false
                  backendServiceArm: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
                  backendAzureRmResourceGroupName: 'terraform-storage-rg'
                  backendAzureRmStorageAccountName: 'terraformstorage05'
                  backendAzureRmContainerName: 'tfstatebackupfile'
                  backendAzureRmKey: 'prodcluster.tfstate'
              - task: TerraformTask@5
                displayName: Terrafrom Plan
                inputs:
                  provider: 'azurerm'
                  command: 'plan'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
                  commandOptions: '-var ssh_public_key=$(sshkey.secureFilePath)'
                  environmentServiceNameAzureRM: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
              - task: TerraformTask@5
                displayName: Terrafrom Apply
                inputs:
                  provider: 'azurerm'
                  command: 'apply'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
                  commandOptions: '-var ssh_public_key=$(sshkey.secureFilePath)'
                  environmentServiceNameAzureRM: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'

      # When you want De-Comission AKS Cluster then Uncomment "destroy task" and the re-run pipeline.

              # - task: TerraformTask@5
              #   displayName: Terrafrom Destroy
              #   inputs:
              #     provider: 'azurerm'
              #     command: 'destroy'
              #     workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
              #     commandOptions: '-var ssh_public_key=$(sshkey.secureFilePath)'
              #     environmentServiceNameAzureRM: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'

# Stage-03

  - stage: DeployArgoCD
    dependsOn: DeployProdCluster
    jobs:
      - job: DeployArgoCD
        displayName: DeployArgoCD
        pool: Default
        steps: 
        - task: AzureCLI@2
          inputs:
            azureSubscription: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
            scriptType: 'bash'
            scriptLocation: 'inlineScript'
            inlineScript: |
              # Commands to get AKS credentials and configure kubectl
                            az aks get-credentials --resource-group terraform-aks-prod --name terraform-aks-prod-cluster --admin --overwrite-kubeconfig
              
              #!/bin/bash
              
              # Set error handling
              set -e
              
              echo "ğŸš€ Starting ArgoCD deployment automation..."
              
              # Function to check if a command exists
              command_exists() {
                  command -v "$1" >/dev/null 2>&1
              }
              
              # Check prerequisites
              if ! command_exists kubectl; then
                  echo "âŒ kubectl is not installed. Please install kubectl first."
                  exit 1
              fi
              
              # Check if namespace exists
              if kubectl get namespace argocd >/dev/null 2>&1; then
                  echo "âœ… ArgoCD namespace already exists"
              else
                  echo "ğŸ“‘ Creating ArgoCD namespace..."
                  kubectl create namespace argocd
              fi
              
              echo "ğŸ“¦ Installing ArgoCD..."
              kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
              
              echo "â³ Waiting for ArgoCD pods to be ready..."
              kubectl wait --for=condition=Ready pods --all -n argocd --timeout=300s
              
              echo "ğŸ”§ Patching ArgoCD server deployment to add '--insecure' flag..."
              kubectl patch deployment argocd-server -n argocd --type='json' \
                -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--insecure"}]'
              
              echo "ğŸ“ Updating ArgoCD ConfigMap..."
              kubectl patch configmap argocd-cmd-params-cm -n argocd --type merge \
                  -p '{"data":{"server.rootpath":"/argo","server.insecure":"true"}}'
              
              echo "ğŸŒ Creating Ingress resource..."
              cat <<EOF | kubectl apply -f -
              apiVersion: networking.k8s.io/v1
              kind: Ingress
              metadata:
                name: argocd-ingress
                namespace: argocd
                annotations:
                  nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
                  nginx.ingress.kubernetes.io/ssl-redirect: "false"
              spec:
                ingressClassName: nginx
                rules:
                - host: argocd.local
                  http:
                    paths:
                    - path: /
                      pathType: Prefix
                      backend:
                        service:
                          name: argocd-server
                          port:
                            number: 80
              EOF
              
              echo "ğŸ”„ Restarting ArgoCD server deployment..."
              kubectl rollout restart deployment argocd-server -n argocd
              
              echo "â³ Waiting for ArgoCD server to be ready (this may take a few minutes)..."
              if kubectl rollout status deployment argocd-server -n argocd --timeout=300s; then
                  echo "âœ… ArgoCD server deployment successfully restarted"
              else
                  echo "âŒ ArgoCD server deployment failed to restart within the timeout period"
                  exit 1
              fi
              
              # Get initial admin password
              echo "ğŸ”‘ Retrieving initial admin password..."
              ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
              
              echo "âœ… ArgoCD deployment completed!"
              echo "ğŸ“‹ Installation Summary:"
              echo "------------------------"
              echo "Username: admin"
              echo "Password: $ARGO_PASSWORD"
              echo "URL: http://<your-ingress-ip>/"
              echo "------------------------"
              
              # Verify deployment
              echo "ğŸ“Š Deployment Status:"
              echo "ArgoCD Pods:"
              kubectl get pods -n argocd
              echo "ArgoCD Service:"
              kubectl get svc argocd-server -n argocd
              echo "ArgoCD Ingress:"
              kubectl get ingress argocd-ingress -n argocd
        # - task: Bash@3
        #   inputs:
        #     targetType: 'inline'
        #     script: |
        #       # Write your commands here
              
        #       #!/bin/bash
              
        #       # Set error handling
        #       set -e
              
        #       echo "ğŸš€ Starting ArgoCD deployment automation..."
              
        #       # Function to check if a command exists
        #       command_exists() {
        #           command -v "$1" >/dev/null 2>&1
        #       }
              
        #       # Check prerequisites
        #       if ! command_exists kubectl; then
        #           echo "âŒ kubectl is not installed. Please install kubectl first."
        #           exit 1
        #       fi
              
        #       # Check if namespace exists
        #       if kubectl get namespace argocd >/dev/null 2>&1; then
        #           echo "âœ… ArgoCD namespace already exists"
        #       else
        #           echo "ğŸ“‘ Creating ArgoCD namespace..."
        #           kubectl create namespace argocd
        #       fi
              
        #       echo "ğŸ“¦ Installing ArgoCD..."
        #       kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
              
        #       echo "â³ Waiting for ArgoCD pods to be ready..."
        #       kubectl wait --for=condition=Ready pods --all -n argocd --timeout=300s
              
        #       echo "ğŸ”§ Patching ArgoCD server deployment to add '--insecure' flag..."
        #       kubectl patch deployment argocd-server -n argocd --type='json' \
        #         -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--insecure"}]'
              
        #       echo "ğŸ“ Updating ArgoCD ConfigMap..."
        #       kubectl patch configmap argocd-cmd-params-cm -n argocd --type merge \
        #           -p '{"data":{"server.rootpath":"/argo","server.insecure":"true"}}'
              
        #       echo "ğŸŒ Creating Ingress resource..."
        #       cat <<EOF | kubectl apply -f -
        #       apiVersion: networking.k8s.io/v1
        #       kind: Ingress
        #       metadata:
        #         name: argocd-ingress
        #         namespace: argocd
        #         annotations:
        #           nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
        #           nginx.ingress.kubernetes.io/ssl-redirect: "false"
        #       spec:
        #         ingressClassName: nginx
        #         rules:
        #         - host: argocd.local
        #           http:
        #             paths:
        #             - path: /
        #               pathType: Prefix
        #               backend:
        #                 service:
        #                   name: argocd-server
        #                   port:
        #                     number: 80
        #       EOF
              
        #       echo "ğŸ”„ Restarting ArgoCD server deployment..."
        #       kubectl rollout restart deployment argocd-server -n argocd
              
        #       echo "â³ Waiting for ArgoCD server to be ready (this may take a few minutes)..."
        #       if kubectl rollout status deployment argocd-server -n argocd --timeout=300s; then
        #           echo "âœ… ArgoCD server deployment successfully restarted"
        #       else
        #           echo "âŒ ArgoCD server deployment failed to restart within the timeout period"
        #           exit 1
        #       fi
              
        #       # Get initial admin password
        #       echo "ğŸ”‘ Retrieving initial admin password..."
        #       ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
              
        #       echo "âœ… ArgoCD deployment completed!"
        #       echo "ğŸ“‹ Installation Summary:"
        #       echo "------------------------"
        #       echo "Username: admin"
        #       echo "Password: $ARGO_PASSWORD"
        #       echo "URL: http://<your-ingress-ip>/"
        #       echo "------------------------"
              
        #       # Verify deployment
        #       echo "ğŸ“Š Deployment Status:"
        #       echo "ArgoCD Pods:"
        #       kubectl get pods -n argocd
        #       echo "ArgoCD Service:"
        #       kubectl get svc argocd-server -n argocd
        #       echo "ArgoCD Ingress:"
        #       kubectl get ingress argocd-ingress -n argocd
        
