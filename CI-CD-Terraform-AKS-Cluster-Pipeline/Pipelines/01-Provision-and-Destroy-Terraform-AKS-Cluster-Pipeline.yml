
trigger:
 paths:
   include:
     - Pipelines/01-Provision-and-Destroy-Terraform-AKS-Cluster-Pipeline.yml
    

variables:
    system.debug: 'true'  

pool: Default
  
#Stage-1: Terraform Validate Stage
   ##Step-1: Publish Artifacts to Pipeline 
   ##Step-2: Install Terraform 
   ##Step-3: Validate Terraform Manifest

stages:
  - stage: TerraformValidate
    jobs:
      - job: TerraformValidateJob
        continueOnError: false
        steps:
        - task: TerraformInstaller@1
          displayName: Terraform Install
          inputs:
            terraformVersion: 'latest'
        - task: TerraformTask@5
          displayName: Terraform Init
          inputs:
            provider: 'azurerm'
            command: 'init'
            workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
            backendAzureRmUseEntraIdForAuthentication: false
            backendServiceArm: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
            backendAzureRmResourceGroupName: 'terraform-storage-rg'
            backendAzureRmStorageAccountName: 'terraformstorage05'
            backendAzureRmContainerName: 'tfstatebackupfile'
            backendAzureRmKey: 'prodcluster.tfstate'
        - task: TerraformTask@5
          displayName: Terraform Validate
          inputs:
            provider: 'azurerm'
            command: 'validate'
            workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'

# Stage-2: Deploy Stages for Prod Cluster

    ## Step-1: Terraform Install
    ## Step-2: Download SSH Secure File
    ## Step-3: Terraform Initialize 
    ## Step-4: Terraform Plan 
    ## Step-5: Terraform Apply 
    ## Step-6: When you want De-Comission AKS Cluster then Uncomment "destroy task" and the re-run pipeline.

  - stage: DeployProdCluster
    jobs:
      - job: DeployProdCluster
        displayName: DeployProdCluster
        pool: Default
        steps: 
              - task: TerraformInstaller@1
                displayName: Terraform Install
                inputs:
                  terraformVersion: 'latest'
              - task: DownloadSecureFile@1
                displayName: Download SSH Key
                name: sshkey
                inputs:
                  secureFile: 'aks-terraform-devops-ssh-key-ubuntu.pub'
              - task: TerraformTask@5
                displayName: Terraform Init
                inputs:
                  provider: 'azurerm'
                  command: 'init'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
                  backendAzureRmUseEntraIdForAuthentication: false
                  backendServiceArm: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
                  backendAzureRmResourceGroupName: 'terraform-storage-rg'
                  backendAzureRmStorageAccountName: 'terraformstorage05'
                  backendAzureRmContainerName: 'tfstatebackupfile'
                  backendAzureRmKey: 'prodcluster.tfstate'
              - task: TerraformTask@5
                displayName: Terrafrom Plan
                inputs:
                  provider: 'azurerm'
                  command: 'plan'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
                  commandOptions: '-var ssh_public_key=$(sshkey.secureFilePath)'
                  environmentServiceNameAzureRM: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
              - task: TerraformTask@5
                displayName: Terrafrom Apply
                inputs:
                  provider: 'azurerm'
                  command: 'apply'
                  workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
                  commandOptions: '-var ssh_public_key=$(sshkey.secureFilePath)'
                  environmentServiceNameAzureRM: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'

      # When you want De-Comission AKS Cluster then Uncomment "destroy task" and the re-run pipeline.

              # - task: TerraformTask@5
              #   displayName: Terrafrom Destroy
              #   inputs:
              #     provider: 'azurerm'
              #     command: 'destroy'
              #     workingDirectory: '$(System.DefaultWorkingDirectory)/CI-CD-Terraform-AKS-Cluster-Pipeline/terraform-manifests'
              #     commandOptions: '-var ssh_public_key=$(sshkey.secureFilePath)'
              #     environmentServiceNameAzureRM: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'


  - stage: DeployArgoCD
    dependsOn: DeployProdCluster
    jobs:
        - job: DeployArgoCD
          displayName: DeployArgoCD
          pool: Default
          steps: 
          - task: Kubernetes@1
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
              azureResourceGroup: 'terraform-aks-prod'
              kubernetesCluster: 'terraform-aks-prod-cluster'
              useClusterAdmin: true
              command: 
              secretType: 'dockerRegistry'
              containerRegistryType: 'Azure Container Registry'
          - task: KubeloginInstaller@0
            displayName: Install kubelogin
            inputs:
              kubeloginVersion: 'latest'
              gitHubConnection: 'GIT-svc-conn-for-GitOps-Workflow-with-ArgoCD-on-Terraform-AKS-Cluster'
          - task: AzureCLI@2
            displayName: Get AKS Credentials
            inputs:
              azureSubscription: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials --resource-group terraform-aks-prod --name terraform-aks-prod-cluster --admin --overwrite-existing
                
                kubelogin convert-kubeconfig -l azurecli
          - task: AzureCLI@2
            displayName: List AKS Nodes
            inputs:
              azureSubscription: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: 'kubectl get nodes'
          - task: Bash@3
            inputs:
              targetType: 'inline'
              script: |
                #!/bin/bash
                
                # Set error handling
                set -e
                
                echo "üöÄ Starting ArgoCD deployment automation..."
                
                # Function to check if a command exists
                command_exists() {
                    command -v "$1" >/dev/null 2>&1
                }
                
                # Check prerequisites
                if ! command_exists kubectl; then
                    echo "‚ùå kubectl is not installed. Please install kubectl first."
                    exit 1
                fi
                                
                # Check if namespace exists
                if kubectl get namespace argocd >/dev/null 2>&1; then
                    echo "‚úÖ ArgoCD namespace already exists"
                else
                    echo "üìë Creating ArgoCD namespace..."
                    kubectl create namespace argocd
                fi
                
                echo "Install Nginx Ingress Controller...."
                kubectl apply -f https://kind.sigs.k8s.io/examples/ingress/deploy-ingress-nginx.yaml
                
                echo "Wait For Nginx Ingress Controller Pod Ready...."
                kubectl wait --namespace ingress-nginx --for=condition=ready pod --selector=app.kubernetes.io/component=controller --timeout=90s
                
                echo "üì¶ Installing ArgoCD..."
                kubectl apply --namespace argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
                
                echo "‚è≥ Waiting for ArgoCD pods to be ready..."
                kubectl wait --for=condition=ready pod --namespace argocd --timeout=90s
                
                echo "üîß Patching ArgoCD server deployment to add '--insecure' flag..."
                kubectl patch deployment argocd-server --namespace argocd --type='json' \
                  -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--insecure"}]'
                
                echo "üìù Updating ArgoCD ConfigMap..."
                kubectl patch configmap argocd-cmd-params-cm --namespace argocd --type merge \
                    -p '{"data":{"server.insecure":"true"}}'
                
                echo "üåê Creating Ingress resource..."
                cat <<EOF | kubectl apply -f -
                apiVersion: networking.k8s.io/v1
                kind: Ingress
                metadata:
                  name: argocd-server-ingress
                  namespace: argocd
                  annotations:
                    kubernetes.io/ingress.class: "nginx"
                    nginx.ingress.kubernetes.io/force-ssl-redirect: "false"
                    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
                    nginx.ingress.kubernetes.io/ssl-passthrough: "true"
                spec:
                  ingressClassName: nginx
                  rules:
                   - host: argocd.cap # Add Your Domain
                     http:
                       paths:
                       - path: /
                         pathType: Prefix
                         backend:
                           service:
                             name: argocd-server
                             port:
                               number: 80
                    
                EOF
                
                echo "üîÑ Restarting ArgoCD server deployment..."
                kubectl rollout restart deployment argocd-server --namespace argocd
                
                echo "‚è≥ Waiting for ArgoCD server to be ready (this may take a few minutes)..."
                if kubectl rollout status deployment argocd-server --namespace argocd --timeout=90s; then
                    echo "‚úÖ ArgoCD server deployment successfully restarted"
                else
                    echo "‚ùå ArgoCD server deployment failed to restart within the timeout period"
                    exit 1
                fi
                
                # Get initial admin password
                echo "üîë Retrieving initial admin password..."
                ARGO_PASSWORD=$(kubectl --namespace argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
                
                echo "‚úÖ ArgoCD deployment completed!"
                echo "üìã Installation Summary:"
                echo "------------------------"
                echo "Username: admin"
                echo "Password: $ARGO_PASSWORD"
                echo "URL: http://<your-ingress-ip>/"
                echo "------------------------"
                
                # Verify deployment
                echo "üìä Deployment Status:"
                echo "ArgoCD Pods:"
                kubectl get pods -n argocd
                echo "ArgoCD Service:"
                kubectl get svc argocd-server -n argocd
                echo "ArgoCD Ingress:"
                kubectl get ingress -n argocd


# Stage-03

  # - stage: DeployArgoCD
  #   dependsOn: DeployProdCluster
  #   jobs:
  #     - job: DeployArgoCD
  #       displayName: DeployArgoCD
  #       pool: Default
  #       steps: 
  #       - task: AzureCLI@2
  #         inputs:
  #           azureSubscription: 'GitOps-ArgoCD-Terraform-AKS-Cluster-svc-conn'
  #           scriptType: 'bash'
  #           scriptLocation: 'inlineScript'
  #           inlineScript: |
  #             # Commands to get AKS credentials and configure kubectl
              
  #             az aks get-credentials --resource-group terraform-aks-prod --name terraform-aks-prod-cluster --admin
              
  #             kubectl get nodes
              
  #             #!/bin/bash
              
  #             # Set error handling
  #             set -e
              
  #             echo "  Starting ArgoCD deployment automation..."
              
  #             # Function to check if a command exists
  #             command_exists() {
  #                 command -v "$1" >/dev/null 2>&1
  #             }
              
  #             # Check prerequisites
  #             if ! command_exists kubectl; then
  #                 echo "‚ùå kubectl is not installed. Please install kubectl first."
  #                 exit 1
  #             fi
              
  #             # Check if namespace exists
  #             if kubectl get namespace argocd >/dev/null 2>&1; then
  #                 echo "‚úÖ ArgoCD namespace already exists"
  #             else
  #                 echo "  Creating ArgoCD namespace..."
  #                 kubectl create namespace argocd
  #             fi
              
  #             echo "  Installing ArgoCD..."
  #             kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
              
  #             echo "‚è≥ Waiting for ArgoCD pods to be ready..."
  #             kubectl wait --for=condition=Ready pods --all -n argocd --timeout=300s
              
  #             echo "  Patching ArgoCD server deployment to add '--insecure' flag..."
  #             kubectl patch deployment argocd-server -n argocd --type='json' \
  #               -p='[{"op": "add", "path": "/spec/template/spec/containers/0/args/-", "value": "--insecure"}]'
              
  #             echo "  Updating ArgoCD ConfigMap..."
  #             kubectl patch configmap argocd-cmd-params-cm -n argocd --type merge \
  #                 -p '{"data":{"server.rootpath":"/argo","server.insecure":"true"}}'
              
  #             echo "  Creating Ingress resource..."
  #             cat <<EOF | kubectl apply -f -
  #             apiVersion: networking.k8s.io/v1
  #             kind: Ingress
  #             metadata:
  #               name: argocd-ingress
  #               namespace: argocd
  #               annotations:
  #                 nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
  #                 nginx.ingress.kubernetes.io/ssl-redirect: "false"
  #             spec:
  #               ingressClassName: nginx
  #               rules:
  #               - host: argocd.local
  #                 http:
  #                   paths:
  #                   - path: /
  #                     pathType: Prefix
  #                     backend:
  #                       service:
  #                         name: argocd-server
  #                         port:
  #                           number: 80
  #             EOF
              
  #             echo "  Restarting ArgoCD server deployment..."
  #             kubectl rollout restart deployment argocd-server -n argocd
              
  #             echo "‚è≥ Waiting for ArgoCD server to be ready (this may take a few minutes)..."
  #             if kubectl rollout status deployment argocd-server -n argocd --timeout=300s; then
  #                 echo "‚úÖ ArgoCD server deployment successfully restarted"
  #             else
  #                 echo "‚ùå ArgoCD server deployment failed to restart within the timeout period"
  #                 exit 1
  #             fi
              
  #             # Get initial admin password
  #             echo "  Retrieving initial admin password..."
  #             ARGO_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
              
  #             echo "‚úÖ ArgoCD deployment completed!"
  #             echo "  Installation Summary:"
  #             echo "------------------------"
  #             echo "Username: admin"
  #             echo "Password: $ARGO_PASSWORD"
  #             echo "URL: http://<your-ingress-ip>/"
  #             echo "------------------------"
              
  #             # Verify deployment
  #             echo "  Deployment Status:"
  #             echo "ArgoCD Pods:"
  #             kubectl get pods -n argocd
  #             echo "ArgoCD Service:"
  #             kubectl get svc argocd-server -n argocd
  #             echo "ArgoCD Ingress:"
  #             kubectl get ingress argocd-ingress -n argocd
        